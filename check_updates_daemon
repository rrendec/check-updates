#!/bin/bash

source /etc/sysconfig/check-updates

TMP=$(mktemp -d)

cleanup() {
	rm -rf $TMP
}

signal() {
	echo "Received signal"
}

# Note: `sleep` is killed with the USR1 signal to avoid printing a job status
# message to stderr (e.g. "check_updates_daemon: line 44: 12215 Terminated").
# This is a hack that relies on the fact that job status is not printed if
# the job dies of a signal that's trapped, and we're already trapping USR1.
# See notify_of_job_status() in jobs.c for details.
int_sleep() {
	sleep $1 &
	local cpid=$!
	wait $cpid || kill -USR1 $cpid
}

trap cleanup EXIT
trap signal SIGUSR1

mtime=$(stat -c '%Y' $CACHE/check_updates 2>/dev/null)
due=$((${mtime:-0} + (RANDOM % INTERVAL_RAND + INTERVAL_FIXED) * 60))
now=$(date '+%s')
delay=$((due > now ? due - now : 1))
retry=1
while true; do
	echo "Sleeping $delay second(s)"
	int_sleep $delay
	echo "Starting cache update ($retry)"
	$LIB/check_updates $OPTS 1>$TMP/out 2>$TMP/err
	ret=$?
	echo $ret >$TMP/ret
	if [[ $ret -eq 3 && $retry -le 3 ]] && grep -q "Error while executing" $TMP/out; then
		delay=30
		retry=$((retry + 1))
		continue
	fi
	tar cf $CACHE/.check_updates.tmp -C $TMP --remove-files out err ret
	mv -f $CACHE/.check_updates.tmp $CACHE/check_updates
	echo "Finished cache update ($ret)"
	delay=$(((RANDOM % INTERVAL_RAND + INTERVAL_FIXED) * 60))
	retry=1
done
